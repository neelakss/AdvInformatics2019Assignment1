# Questions

## HPC good citizenship

1. On the UCI cluster, the resource request "-pe openmp 64" refers to the number of processors requested.  Does that
   request mean that your commands will use multiple processors?
>"-pe openmp 64" refers to 64 processor cores being used for a specific job. This specifically requests 64 parallel enviornments. So if the scheduler finds a single node with all 64 cores available, it will pick that node and assign our job to that compute node. If no node is found, the job goes into the queue waiting area until a node becomes available. This means the commands will use multiple processor cores, however the number of cores being used at any given point might differ based on the computational need of the said command.
2. In general, how do you know how many processors, how much RAM, how many files would be required/needed/written by the
   jobs you are running on the cluster?
> Commands "/usr/bin/time -v" or "/usr/bin/time -f" can be used for the above mentioned job
<pre><code>/usr/bin/time -v sleep 2.0 &> output.txt
less output.txt
</code></pre>
<pre><code>Command being timed: "sleep 2.0"
User time (seconds): 0.00
System time (seconds): 0.00
Percent of CPU this job got: 0%
Elapsed (wall clock) time (h:mm:ss or m:ss): 0:02.00
Average shared text size (kbytes): 0
Average unshared data size (kbytes): 0
Average stack size (kbytes): 0
Average total size (kbytes): 0
Maximum resident set size (kbytes): 1652
Average resident set size (kbytes): 0
Major (requiring I/O) page faults: 0
Minor (reclaiming a frame) page faults: 68
Voluntary context switches: 2
Involuntary context switches: 0
Swaps: 0
File system inputs: 0
File system outputs: 0
Socket messages sent: 0
Socket messages received: 0
Signals delivered: 0
Page size (bytes): 4096
Exit status: 0
</pre></code>
<pre><code>(/usr/bin/time -f "%E %e %S %U %P" sleep 2.0 /usr/bin/time -f "%M %t %K %D %p %X %Z %F %R %W %c %w" sleep 2.0 /usr/bin/time -f "[%C] %I %O %r %s %k %x" sleep 2.0) &> output.txt
less output.txt
</code></pre>
<pre><code>0:02.00 2.00 0.00 0.00 0%
1648 0 0 0 0 0 4096 0 68 0 0 4
[sleep 2.0] 0 0 0 0 0 0
</code></pre>
> The code is explained as follows:
<pre><code>%E     Elapsed real time (in [hours:]minutes:seconds).
%e     (Not in tcsh.) Elapsed real time (in seconds).
%S     Total number of CPU-seconds that the process spent in kernel mode.
%U     Total number of CPU-seconds that the process spent in user mode.
%P     Percentage of the CPU that this job got, computed as (%U + %S) / %E.
%M     Maximum resident set size of the process during its lifetime, in Kbytes.
%t     (Not in tcsh.) Average resident set size of the process, in Kbytes.
%K     Average total (data+stack+text) memory use of the process, in Kbytes.
%D     Average size of the process's unshared data area, in Kbytes.
%p     (Not in tcsh.) Average size of the process's unshared stack space, in Kbytes.
%X     Average size of the process's shared text space, in Kbytes.
%Z     (Not in tcsh.) System's page size, in bytes.  This is a per-system constant, but varies between systems.
%F     Number of major page faults that occurred while the process was running. These are faults where the page has to be read in from disk.
%R     Number of minor, or recoverable, page faults.  These arefaults for pages that are not valid but which have not yetbeen claimed by other virtual pages.  Thus the data in the page is still valid but the system tables must be updated.
%W     Number of times the process was swapped out of main memory.
%c     Number of times the process was context-switched involuntarily (because the time slice expired).
%w     Number of waits: times that the program was context-switched voluntarily, for instance while waiting for an I/O operation to complete.
%I     Number of filesystem inputs by the process.
%O     Number of filesystem outputs by the process.
%r     Number of socket messages received by the process.
%s     Number of socket messages sent by the process.
%k     Number of signals delivered to the process.
%C     (Not in tcsh.) Name and command-line arguments of the command being timed.
%x     (Not in tcsh.) Exit status of the command.
</code></pre>
3. In order to be a "good citizen", you need to have some idea of much RAM your job requires.  In particular, you need
   to know the "peak" (i.e., maximum) RAM required at any point during execution.  Show an example of the shell command
   that you would use on a Linux machine to measure run time and peak ram usage of an arbitrary command, where the time/peak RAM values are written to a file.
> Using grep one could easily edit the output generated by a bash command as given below:
<pre><code>{ /usr/bin/time -v sleep 2.0 >/dev/null; } 2>&1 | grep -e Elapsed -e Maximum > textfile.txt
less textfile.txt
</code></pre>
<pre><code>Elapsed (wall clock) time (h:mm:ss or m:ss): 0:02.00
Maximum resident set size (kbytes): 1652
</code></pre>
4. What are the units of your answer for number 3?
> The run time has the units as "minutes:seconds" and the units for the peak ram usage is Kbytes.
5. What are the bash commands for the following operations:  
* Checking that a file exists
    <pre><code>file=./output.txt #can change the name depending on requirement
  if [ -e "$file" ]; then
    echo "File exists"
  else 
    echo "File does not exist"
  fi   
  </code></pre>
  <pre><code>File exists
  </pre></code>
 * Checking that a file exists and is not empty
   <pre><code>file=./output.txt
   if [ -s "$file" ]; then 
     echo " File exists and is not empty "
   else
     echo " File does not exist, or is empty "
   fi
   </code></pre>
   <pre><code>File exists and is not empty
   </code></pre>
6. How would you use the commands from your answer to 5 to write a work flow for HPC that only runs a job if the
   expected output file is **not** present.
> The command given below could be used to do the same:
<pre><code>file=./output1.txt
if [ ! -e "$file" ]; then
/usr/bin/time -v sleep 2.0 &> $file ;
fi
less output1.txt
</code></pre>
<pre><code>Command being timed: "sleep 2.0"
User time (seconds): 0.00
System time (seconds): 0.00
Percent of CPU this job got: 0%
Elapsed (wall clock) time (h:mm:ss or m:ss): 0:02.00
Average shared text size (kbytes): 0
Average unshared data size (kbytes): 0
Average stack size (kbytes): 0
Average total size (kbytes): 0
Maximum resident set size (kbytes): 1652
Average resident set size (kbytes): 0
Major (requiring I/O) page faults: 0
Minor (reclaiming a frame) page faults: 68
Voluntary context switches: 4
Involuntary context switches: 0
Swaps: 0
File system inputs: 0
File system outputs: 0
Socket messages sent: 0
Socket messages received: 0
Signals delivered: 0
Page size (bytes): 4096
Exit status: 0
</code></pre>
## Trickier questions

7. Would your answer to number 3 work on Apple's OS X operating system?  If no, do you have any idea why not? 
> Mac OSX would need GNU as -v (--verbose) is the GNU extension of time (Mac OSX doesnt ship with GNU stack(version 1.7)), which is why one would need to install GNU time with homebrew. "gtime --verbose" command could be used to do the same thing as seen in answer number 3.
8. Most of the HPC nodes have 512Gb (gigabytes) of RAM. Let's say you have a job that will require **no more** than 24Gb
   of RAM.  How would you request resources so that you can run more than one job on a node **and** not cause nodes to
   crash?  Show an example of a skeleton HPC script as part of your answer.  **Knowing how to do this is super important
   and will save you loads of frustration and prevent you from taking out your colleagues' jobs on the cluster,
   preventing you from getting nasty emails from Harry!!!!!!!!!!!**
> Using the command "-l mem_free=XG" one could specify the RAM requirement for the jobs one needs to run. The following is the skeleton script for running multiple serial jobs on one node:
<pre><code>#! /bin/bash/
#$ -N MPJ 
#$ -pe openmp 8-64
#$ -q free*,bio,epyc
#$ -R y
#$ -l mem_free=96G
#$ -m beas

qsub job1.sh
qsub job2.sh
qsub job3.sh
qsub job4.sh
</code></pre>
